<H3>Лабораторная работа №2<H3>
<H2>Структура и условия заданий, а также комментарии к каждому:</H2>

<A HREF="#chap1">Задание 1</A><br>
<A HREF="#chap2">Задание 2</A><br>
<A HREF="#chap3">Задание 3</A><br>
<A HREF="#chap4">Задание 4</A><br>
<A HREF="#chap5">Задание 5</A><br>


<A NAME="chap1"></A>
<H1>Задание 1</H1>
<A HREF="#chap1.2">задание 1.2</A><br>
<A HREF="#chap1.3">задание 1.3</A><br>

<A NAME="chap1.2"></A>
<b>Задание 1.2</b>
Человек.<br>
Создайте сущность Человек, которая описывается:</b><br>
1)Имя: строка<br>
2)Рост: целое число<br>
Может возвращать текстовое представление вида “Name, рост: height”, где Name и height это
переменная с именем и ростом.<br>
Необходимо создать и вывести на экран следующих людей:<br>
1. Человек с именем “Клеопатра” и ростом 152<br>
2. Человек с именем “Пушкин ” и ростом 167<br>
3. Человек с именем “Владимир ” и ростом 189 <br>
В основной программе у пользователя запрашиваем количество имён, которых он хочет создать. Там же совершаем проверку, т.к количество не может быть меньше 0<br>
Создаём массив с людьми (их данными) и с помощью дополнительного класса <b>Metods</b> и заполняем его.
Далее используя цикл <b>for</b> вывожу информацию о каждом человеке<br>
При решении задачи был создан класс <b>Human</b> :<br>
<b>String Name</b> - свойство, отвечающее за имя.<br>
<b>int height</b> - свойство, отвечающее за рост.<br>
<b>setName</b> - нужен для заполнения поля с именем. При вводе осуществляется проверка имени на допустимые символы.<br>
<b>setHeight</b> - нужен для заполнения поля с ростом. При вводе осуществляется проверка на допустимые значения (не меньше 60 и не больше 270).<br>
Метод <b>createHuman()</b> - заполняет поля имени и роста вызывая сеттеры для имени и роста.<br>
Класс <b>Metods :</b> <br>
<b>boolean CorrectName(String s)</b> - метод проверяет имя на длину(не меньше 2),написано ли оно кириллицей(от заглавных букв до маленьких) и что в имени может быть дефис (но не в начале и конце).<br>
<b>Human[] add(int n)</b> - метод для заполнения массива, в нём каждый элемент является сущностью <b>Human</b>.Внутри метода вызывается конструктор <b>createHuman()</b> для заполнения элемента массива.<br> 
<b> Пример работы программы: </b><br>
![Вывод созданных пользователем людей](https://github.com/KatValentina/Java-Laboratory/blob/main/screenshot2/Work%20programm1.2.png)<br>
<b>Обработка ошибочных вводов:</b><br>
![Ошибки в вводе имён](https://github.com/KatValentina/Java-Laboratory/blob/main/screenshot2/Error1.2.1.png)
![Ошибки в вводе роста](https://github.com/KatValentina/Java-Laboratory/blob/main/screenshot2/Error1.2.2.png)<br>


<A NAME="chap1.3"></A>
<b>Задание 1.3</b>
Имена.<br>
Создайте сущность Имя, которая описывается тремя параметрами: Фамилия, Личное имя, Отчество. Имя может быть приведено к строковому виду, включающему традиционное представление всех трех параметров: Фамилия Имя Отчество (например “Иванов Иван Иванович”). Необходимо предусмотреть возможность того, что какой-либо из параметров может быть не задан, и в этом случае он не учитывается при приведении к текстовому виду.<br>
Необходимо создать следующие имена:<br>
1) Клеопатра<br>
2) Пушкин Александр Сергеевич<br>
3) Маяковский Владимир<br>
Обратите внимание, что при выводе на экран, не заданные параметры никак не участвуют в образовании строки.<br>
Как и в прошлом задании в основной программе у пользователя запрашиваем количество имён, которых он хочет создать. Там же совершаем проверку, т.к количество не может быть меньше 0<br>
Создаём массив с людьми (их данными) и с помощью дополнительного класса <b>Metods</b> и заполняем его.
Далее используя цикл <b>for</b> вывожу информацию о каждом человеке<br>
При решении задачи был создан класс <b>Name</b> :<br>
<b>String Surname</b> - свойство, отвечающее за фамилию.<br>
<b>String NaMe</b> - свойство, отвечающее за личное имя.<br>
<b>String MiddleN</b> - свойство, отвечающее за отчество.<br>
Метод <b>String inputName(String name)</b> - отвечает за ввод значений в свойства. В нём вызывается метод <b>correctName(name)</b>, который отвечает за корректный ввод значений. В методе пока пользователь не введёт корректное будет продолжаться проверка имени. Метод возвращает корректное имя.<br>



<A NAME="chap2"></A>
<H1>Задание 2</H1>
<A HREF="#chap2.2">задание 2.2</A><br>
<A HREF="#chap2.4">задание 2.4</A><br>
<A HREF="#chap2.6">задание 2.6</A><br>
<A HREF="#chap2.8">задание 2.8</A><br>
<A HREF="#chap2.10">задание 2.10</A><Br>

<A NAME="chap2.2"></A>
<b>Задание 2.2</b>
Безопасное деление.<br>
Дана сигнатура метода: <b>public double safeDiv (int x, int y);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал деление x
на y, и при этом гарантировал, что не будет выкинута ошибка деления на 0. При
делении на 0 следует вернуть из метода число 0. Подсказка: смотри
ограничения на операции типов данных.<br>
Пример 1:<br>
x=5 y=0<br>
результат: 0<br>
Пример 2:<br>
x=8 y=2<br>
результат: 4<br>
В методе <b>public double safeDiv (int x, int y);</b> добавлено условие <b>if (x==0 || y==0)</b>, которое возвращает 0 при делении на 0 (как по условию), а также возвращает 0, когда 0 делят на какое-либо число. Так как метод должен возвращать тип <b>double</b>, то в строке <b>return (double) x/y</b> прописываем double. Поскольку при делении двух переменных типа <b>int</b> тоже получается тип <b>int</b>.

<A NAME="chap2.4"></A>
<b>Задание 2.4</b>
Строка сравнения.<br>
Дана сигнатура метода: <b>public String makeDecision (int x, int y);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал строку,
которая включает два принятых методом числа и корректно выставленный
знак операции сравнения (больше, меньше, или равно).<br>
Пример 1:<br>
x=5 y=7<br>
результат: “5 < 7”<br>
Пример 2:<br>
x=8 y=-1<br>
результат: “8 > -1”<br>
Пример 3:<br>
x=4 y=4<br>
результат: “4 == 4”<br>
В методе <b>public String makeDecision (int x, int y);</b> используются простые сравнения <b>if (x!=y)</b> и <b>if (x>y)</b>. Так как метод должен возвращать тип <b>String</b>, то для возвращения строки с готовым сравнением используется метод <b>toString()</b> класса <b>Integer</b>, который возвращает объект <b>String</b>, представляющий указанное целое число.

<A NAME="chap2.6"></A>
<b>Задание 2.6</b>
Тройная сумма.<br>
Дана сигнатура метода: <b>public boolean sum3 (int x, int y, int z);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
два любых числа (из трех принятых) можно сложить так, чтобы получить
третье.<br>
Пример 1:<br>
x=5 y=7 z=2<br>
результат: true<br>
Пример 2:<br>
x=8 y=-1 z=4<br>
результат: false<br>
Результат определяется в методе <b>public boolean sum3 (int x, int y, int z);</b> с помощью конструкции <b>(x+y==z || x+z==y || y+z==x)</b>. Если хотя бы одно из условий правдиво (=true), то результат работы метода будет возвращённый <b>true</b>. Только когда все условия ложны(=false), то будет возвращён <b>false</b>.<br>

<A NAME="chap2.8"></A>
<b>Задание 2.8</b>
Возраст.<br>
Дана сигнатура метода: <b>public String age (int x);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал строку, в
которой сначала будет число х, а затем одно из слов:<br>
год<br>
года<br>
лет<br>
Слово “год” добавляется, если число х заканчивается на 1, кроме числа 11.<br>
Слово “года” добавляется, если число х заканчивается на 2, 3 или 4, кроме чисел
12, 13, 14.<br>
Слово “лет” добавляется во всех остальных случаях.<br>
Подсказка: оператор % позволяет получить остаток от деления.<br>
Пример 1:<br>
x=5<br>
результат: “5 лет”<br>
Пример 2:<br>
x=31<br>
результат: “31 год”<br>
Пример 3:<br>
x=44<br>
результат: “44 года”<br>
В методе main происходит проверка, чтобы введённый год пользователем был строго больше 0 (или строго меньше 100) и после этой проверки вызывается метод <b>public String age (int x);</b>. В нём находится последняя цифра года, а далее:<br>
if (s>4 || (x>=11 && x<=14)) { <=проверяем на особенные случаи (исключаем их)<br>
	return Integer.toString(x)+" лет";<br>
} else if (s>=2) { <= оканчиваются на 2,3,4,кроме чисел 12, 13, 14 <br>
	return Integer.toString(x)+" года";<br>
} else {<br>
	return Integer.toString(x)+" год";<=оканчиваются на 1, кроме 11<br>
}<br>

<A NAME="chap2.10"></A>
<b>Задание 2.10</b>
Вывод дней недели.<br>
Дана сигнатура метода: <b>public void printDays (String x);</b><br>
В качестве параметра метод принимает строку, в которой записано название
дня недели. Необходимо реализовать метод таким образом, чтобы он выводил
на экран название переданного в него дня и всех последующих до конца недели
дней. Если в качестве строки передан не день, то выводится текст “это не день
недели”. Первый день понедельник, последний – воскресенье. Вместо if в данной
задаче используйте switch.<br>
Пример 1:<br>
x=”четверг” <br>
результат:<br>
четверг <br>
пятница <br>
суббота <br>
воскресенье <br>
Пример 2:<br>
x=”чг”<br>
результат:<br>
это не день недели <br>
При считывании дня недели в методе main использовался только метод <b>next()</b>, поскольку он позволяет дождаться ввода какого-либо символа(не будет проверки на пустую строку), а также он не считывает остальные символы после пробела.

<A NAME="chap3"></A>
<H1>Задание 3</H1>
<A HREF="#chap3.2">задание 3.2</A><br>
<A HREF="#chap3.4">задание 3.4</A><br>
<A HREF="#chap3.6">задание 3.6</A><br>
<A HREF="#chap3.8">задание 3.8</A><br>
<A HREF="#chap3.10">задание 3.10</A><Br>

<A NAME="chap3.2"></A>
<b>Задание 3.2</b>
Числа наоборот.<br>
Дана сигнатура метода: <b>public String reverseListNums (int x);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал строку, в
которой будут записаны все числа от x до 0 (включительно).<br>
Пример:<br>
x=5<br>
результат: “5 4 3 2 1 0”<br>
В методе main простым условным оператором проверяем x согласно условиям <b>if (x<0)</b>.
В методе <b>public String reverseListNums (int x);</b> с помощью цикла <b>for</b> и метода <b>toString(i)</b> (про который писала выше) составляем строку с обратным отсчётом от x до 0.

<A NAME="chap3.4"></A>
<b>Задание 3.4</b>
Степень числа.<br>
Дана сигнатура метода: <b>public int pow (int x, int y);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал результат
возведения x в степень y.<br>
Подсказка: для получения степени необходимо умножить единицу на число x, и
сделать это y раз, т.е. два в третьей степени это 1*2*2*2<br>
Пример:<br>
x=2<br>
y=5<br>
результат: 32<br>
В методе main проверяем, что степени числа положительная(т.к по условию метод <b>public int pow (int x, int y);</b> должен вернуть целое значение).<br>
В методе <b>public int pow (int x, int y);</b> первое значение числа в степени равно 1 (так как любое a^0==1)а далее уже через цикл <b>for</b> считаем число x в степени y.

<A NAME="chap3.6"></A>
<b>Задание 3.6</b>
Одинаковость.<br>
Дана сигнатура метода: <b>public boolean equalNum (int x);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
все знаки числа одинаковы, и false в ином случае.<br>
Подсказки:<br>
intx=123%10; // х будет иметь значение 3<br>
intу=123/10; // у будет иметь значение 12<br>
Пример 1:<br>
x=1111<br>
результат: true<br>
Пример 2:<br>
x=1211<br>
результат: false<br>
В методе <b>public boolean equalNum (int x);</b>:
1) Если пользователь ввёл отрицательное число, то меняем его на положительное.
Так как дальше будем работать именно с его "положительностью".<br>
2) Находим последнюю цифру числа.<br>
3) Далее: <br>
while (x > 0) { <=пока все цифры в числе "не закончились". <br>
	if (x % 10 != c) { <= если "конец" числа не равен с самого начала найденной последней цифрой <br>
		return false; <= Нашли различие в числе <br>
	} 
	x = x/10; <= обновляем число, убираем проверенную последнюю цифру<br>
}<br>

<A NAME="chap3.8"></A>
<b>Задание 3.8</b>
Левый треугольник.<br>
Дана сигнатура метода: <b>public void leftTriangle (int x);</b><br>
Необходимо реализовать метод таким образом, чтобы он выводил на экран
треугольник из символов ‘*’ у которого х символов в высоту, а количество
символов в ряду совпадает с номером строки.<br>
Пример 1:<br>
x=2<br>
результат:<br>
*<br>
**<br>
Пример 2:<br>
x=4<br>
результат:<br>
*<br>
**<br>
***<br>
****<br>
В методе main проверяем, что число строго больше 0(т.к треугольника с 0 стороной нет).
В методе <b>public void leftTriangle (int x);</b> индекс i - отвечает за длину стороны(по строкам), а y - отвечает за количество  звёздочек в строке.<br>

<A NAME="chap3.10"></A>
<b>Задание 3.10</b>
Угадайка.<br>
Дана сигнатура метода: <b>public void guessGame()</b><br>
Необходимо реализовать метод таким образом, чтобы он генерировал
случайное число от 0 до 9, далее считывал с консоли введенное пользователем
число и выводил, угадал ли пользователь то, что было загадано, или нет. Метод
запускается до тех пор, пока пользователь не угадает число. После этого
выведите на экран количество попыток, которое потребовалось пользователю,
чтобы угадать число.<br>
Пример:<br>
Введите число от 0 до 9:<br>
5<br>
Вы не угадали, введите число от 0 до 9:<br>
9<br>
Вы угадали!<br>
Вы отгадали число за 2 попытки<br>
В методе <b>public void guessGame()</b> с помощью подключённого пакета <b>java.util.Random</b> выбирается число компьютером. Инициализируется счётчик попыток.
Используя цикл <b>while (comp != user)</b> игра продолжается, пока пользователь не введёт такое же число, которое "загадал" компьютер.

<A NAME="chap4"></A>
<H1>Задание 4</H1>
<A HREF="#chap4.0">Дополнительно</A><br>
<A HREF="#chap4.2">задание 4.2</A><br>
<A HREF="#chap4.4">задание 4.4</A><br>
<A HREF="#chap4.6">задание 4.6</A><br>
<A HREF="#chap4.8">задание 4.8</A><br>
<A HREF="#chap4.10">задание 4.10</A><Br>

<A NAME="chap4.0"></A>
<b>Дополнительно</b>
Чтобы облегчить выполнение этого блока задач были написаны 2 метода: <br>
1) <b>public int[] addArr(int n)</b> - метод для заполнения массива числами (использует цикл for)<br>
2) <b>public void printArr(int[] arr)</b> - метод для вывод массива в консоль (тоже использует цикл for)
Также во всех заданиях выполняется проверка на размер массива(строго больше 0)

<A NAME="chap4.2"></A>
<b>Задание 4.2</b>
Поиск последнего значения.<br>
Дана сигнатура метода: <b>public int findLast (int[] arr, int x);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал индекс
<u>последнего</u> вхождения числа x в массив arr. Если число не входит в массив –
возвращается -1.<br>
Пример:<br>
arr=[1,2,3,4,2,2,5]<br>
x=2<br>
результат: 5<br>
После проверки размера массива, заполнения его данными и ввода числа x в методе <b>public int findLast (int[] arr, int x);</b> циклом <b>for</b> проходим массив с конца и ищем число в массиве равное числу х. Как только мы его находим, возвращаем его индекс. Если мы достигли конца массива, но не нашли равенство, то возвращаем -1.

<A NAME="chap4.4"></A>
<b>Задание 4.4</b>
Добавление в массив.<br>
Дана сигнатура метода: <b>public int[]add (int[] arr, int x, int pos);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, который будет содержать все элементы массива arr, однако в позицию
pos будет вставлено значение x.<br>
Пример:<br>
arr=[1,2,3,4,5]<br>
x=9<br>
pos=3<br>
результат: [1,2,3,9,4,5]<br>
После проверки размера массива, заполнения его данными, ввода числа x и ещё проверкой введённой позиции (индекса) pos (не должен выходить за рамки массива) вызываем метод <b>public int[]add (int[] arr, int x, int pos);</b>. В методе создаём новый массив размером больше на 1 изначального(т.к добавляем 1 число). Переписываем все данные до места вставки, потом записываем число х на индекс(pos), далее также заполняем новый массив данными из старого массива, включая число, которое раньше стояло на месте x. Используем циклы <b>for</b>.

<A NAME="chap4.6"></A>
<b>Задание 4.6</b>
Реверс.<br>
Дана сигнатура метода: <b>public void reverse (int[] arr);</b><br>
Необходимо реализовать метод таким образом, чтобы он изменял массив arr.
После проведенных изменений массив должен быть записан задом-наперед.<br>
Пример:<br>
arr=[1,2,3,4,5]<br>
результат: arr=[5,4,3,2,1]<br>
После проверки размера массива и заполнения массива данными, вызываем метод <b>public void reverse (int[] arr);</b>:<br>
Мы мысленно делим массив пополам и будем менять данные пар с индексами {0,n}; {1,n-1} и т.д.<br>
Для этого в цикле <b>for</b> сохраняем данные 1 числа из пары. На место 1 числа пары ставим второе число пары, далее записываем на 2 число пары данные 1 числа(которые сохранили) и т.д, пока не поменяем данные внутри последней пары.<br> 

<A NAME="chap4.8"></A>
<b>Задание 4.8</b>
Объединение.<br>
Дана сигнатура метода: <b>public int[] concat (int[] arr1,int[] arr2);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, в котором сначала идут элементы первого массива (arr1), а затем
второго (arr2).<br>
Пример:<br>
arr1=[1,2,3]<br>
arr2=[7,8,9]<br>
результат: [1,2,3,7,8,9]<br>
Заполняем 2 массива данными и вызываем метод <b>public int[] concat (int[] arr1,int[] arr2);</b>.Для того, чтобы соединить 2 массива в 1 массив (третий) найдём его размер (размер 1 + размер 2). И сначала в новый третий массив записываем 1 массив через цикл <b>for</b>. А далее так же через цикл <b>for</b> записываем данные 2 массива в третий массив.

<A NAME="chap4.10"></A>
<b>Задание 4.10</b>
Удалить негатив.<br>
Дана сигнатура метода: <b>public int[] deleteNegative (int[] arr);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, в котором записаны все элементы массива arr кроме отрицательных.
Пример:<br>
arr=[1,2,-3,4,-2,2,-5]<br>
результат: [1,2,4,2]<br>
Как в задачах до этого заполняем массив значениями и вызываем метод <b>public int[] deleteNegative (int[] arr);</b>. В нём считаем количество отрицательных чисел в массиве:<br>
1) Если их не оказалось, то возвращаем тот же самый массив.<br>
2) Если количество отриц. чисел равно размеру массива, то выводим пустой массив.<br>
3) Если количество меньше длины массива, то создаём новый массив, длинной (длинна изначального массива - количество отриц. чисел). И через цикл <b>for</b> заполняем новый массив положительными числами(0 тоже) из старого. => Выводим новый массив.<br>
 