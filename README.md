# Лабораторная работа № 4
___

## Задача 1
  + ### Задача 1.1. Обобщенная коробка
```
Создайте сущность Коробка, которая обладает следующими характеристиками:
- Может хранить один произвольный объект в один момент времени.
- Объект можно получить и разместить на хранение в любой момент времени.
- Если объект забирают из коробки – ссылку на этот объект необходимо обнулить.
- Если объект кладут в коробку, но она не пуста – необходимо выкинуть исключение.
- Имеет метод проверки на заполненность.
- Методы класса должны работать с тем типом данных, который был указан во время
создания объекта
Создайте Коробку которая может хранить целочисленное значение, разместите туда число 3.
Передайте Коробку в какой-либо метод, извлеките значение, и выведите его на экран.
```
В основной программе создаётся коробка с типом **Integer** : `Box<Integer> box = new Box<Integer>()`. 
Далее у пользователя запрашивается значение, которое он хочет "положить" в коробку.
 Это значение создаётся с типом **int** и проверяется методом `Metods.isInt()` и с помощью метода `putItem(x)` "кладём" значение в коробку.
На следующем шаге методом `isEmpty()` проверяем, что в коробке есть значение. Передаём коробку в метод `onBox(box)`, 
где извлекаем значение из коробки с помощью метода `takeItem()`. Снова вызываем метод `isEmpty()`, что мы "забрали" объект из коробки, т.е. ссылка на этот объект **null**.  
В классе **Main** был написан метод **void onBox(Box<Integer> box)**
```java
if (box.isEmpty()) { //проверяем, в коробке есть объект
    Integer value = box.takeItem();
    System.out.println("В коробке лежит: " + value); //выводим лбъект, который был в коробке
} else {
    throw new IllegalStateException("Коробка пуста!");
}
```
#### При решении задачи был создан класс Box < T > : 
**T item** — свойство, отвечающее за хранимый объект.  
**Box()** — конструктор, инициализирует пустую коробку.  
**boolean isEmpty()** — проверяет, пуста ли коробка.
```java
if ( this.item!=null ) {
    return true; //возвращает true если в коробке есть значение
} else {
    return false; //если коробка пуста, то false
}
```
**void putItem(T item)** — размещает объект в коробку. Если коробка уже заполнена, выбрасывает `IllegalStateException.`  
**T takeItem()** — извлекает объект из коробки и обнуляет ссылку. Если коробка пуста, выбрасывает `IllegalStateException.`  
Переопределение метода **toString()** — возвращает строковое представление коробки.  
#### Также для решения использовался пакет ru.kataeva.metods, класс Metods: 
Метод **isInt()** — Проверяет ввод пользователя на корректность числового значения
```java
System.out.print("Введите число: ");
String s = scanner.nextLine();
if (s.isEmpty()) {
    throw new IllegalStateException("Вы оставили ввод пустым."); //Проверяет, что строка не пуста 
}

if (s.trim().length() != s.length()) { //Проверяет, что строка не содержит пробелов.
    throw new IllegalStateException("В введённых данных есть пробелы.");
}
try {
    return Integer.parseInt(s); //Пытается преобразовать ввод в Integer
} catch (NumberFormatException e1) {
    try {
        return Double.parseDouble(s); //затем в Double.
    } catch (NumberFormatException e2) {
        System.out.println("Введённые данные не число.");
    }
}
```
#### Пример работы программы  
![Правильное выполнение](https://github.com/KatValentina/Java-Laboratory/blob/main/screenshot4/Workprog1.1.png)
___

#### Обработка ошибок
___
- Если оставить коробку пустой
```java
                                Box<Integer> box = new Box<Integer>();
  //                            int x = Metods.isInt().intValue();
  //                            box.putItem(x);
 ```
**Вывод**
```
Вам предстоит ввести число,которое вы хотите положить в коробку
В коробке что-то есть? false
Коробка пуста!
```
___
- Если попробовать "положить" объект в коробку, когда она не пуста
```java
int x = Metods.isInt().intValue();
box.putItem(x);
System.out.println(box.toString());
box.putItem(4);
```
**Вывод**
```
Вам предстоит ввести число,которое вы хотите положить в коробку
Введите число: 4
Box{4}
В коробке уже есть предмет!
```
___

  + ### Задача 1.3. Сравнимое
```
Создайте ссылочный тип Сравнимое, гарантирующий наличие по данной ссылке метода со следующими характеристиками:
- Называется “сравнить”
- Принимает объект.
- Тип принимаемого объекта может быть изменен без изменения самого Сравнимого.
- Возвращает целое число.
```
В основной программе пользователь вводит два целых числа через **Metods.isInt()**. Метод был описан в задании 1.1. Далее создаются объекты класса **Num** с введёнными значениями. 
Затем вызывается метод **compare()** для сравнения чисел.  
#### При решении задачи был создан интерфейс Comparable < T > :
Метод без реализации **int compare(T item)** — сравнивает текущий объект с переданным и возвращает целое число
#### Также для решения используется класс Num implements Comparable<Num>: 
**int value** — свойство, отвечающее за число пользователя(1 число для сравнения).  
**Геттер int getValue()** — геттер, нужен для внесения значения в свойство класса.  
**Конструктор Num(int n)** — конструктор, создающий объект класса **Num** со свойством n.  
Класс **Num** будет применять интерфейс **Comparable**.  
В этом классе был реализован метод **compare(Num n)** где возвращается разность первого числа и второго.  
```
- Если вывелось отрицательное число, то первое число меньше второго.
- Если вывелось положительное, то первое число больше второго.
- Если вышло 0, то числа равны
```
#### Пример работы программы 
```
Сейчас вам предстоит ввести значения, которые хотите сравнить
Введите число: 24
Введите число: 8
Если вывелось отрицательное число, то первое число меньше второго.
Если вывелось положительное, то первое число больше второго. 
Если вышло 0, то числа равны
Результат сравнения: 16
```
---

#### Обработка ошибок 

---
- Если один из сравнимых объектов класса **Num** null
```java
int x = Metods.isInt().intValue();
Num n1 = null;
int y = Metods.isInt().intValue();
Num n2 = new Num(y);
```
**Вывод**
```
Сейчас вам предстоит ввести значения, которые хотите сравнить
Введите число: 74
Введите число: 54
Один или оба объекта null
```
---

## Задача 2.2 Поиск максимума
```
Создайте метод, принимающий набор Коробок из задачи 4.1.1 и возвращающий максимальное из их значений в формате double. 
Принимаемые методом Коробки могут быть параметризованы любыми видами чисел.
```
В основной программе создаются 3 коробки, которые являются объектами класса **Box** типов: **int**,**double**,**float**.  
Затем последовательно заполняем коробки с клавиатуры, проверяя каждый элемент через метод **Metods.isInt()**. Далее эти коробки 
передаём в массив коробок, который может принимать коробки содержащие свойство любого типа, являющиеся **Number** или наследующиеся от **Number**.
Соответственно передаём этот массив в метод **findMaxValue(boxes)**, где находим максимальное значение и выводим его.  
Для решения в классе **Main** был создан метод **double findMaxValue(Box<? extends Number>[] boxes)** для нахождения максимального значения
```java
if (boxes == null || boxes.length == 0) {
    throw new IllegalArgumentException("Массив коробок не может быть пустым или null");
}

double max=0; //начальное значение для максимального
boolean found = false; //флаг, который показывает, что значение было найдено

for (Box<? extends Number> box : boxes) { //проходимся по массиву коробок
    if (box != null && box.isEmpty()) { //если коробка не null и она не пуста, то проверяем её
        Number value = box.getItem(); //достаём значение
        double doubleValue = value.doubleValue(); // преобразуем в double для удобства сравнения
        if (!found) {
            max = doubleValue;
            found = true; //если нашли хоть одну не пустую коробку, то ставим флаг
        } else if (doubleValue > max) {
            max = doubleValue;
        }
    }
}

if (!found) {
    throw new IllegalArgumentException("Не найдено ни одной не пустой коробки");
}
return max;
```
В решении используется класс **Box<T>**, который описан в задаче 1.1
#### Пример работы программы 
```
Вам предстоит создать 3 коробки.
Первая коробка cо значением int(если было введено вещественное число,то оно будет преобразовано в целое.
Введите число: 5
Вторая коробка со значением double.
Введите число: 14.74
Третья коробка со значением float. 
Введите число: -24.89
Максимальное значение: 14.74
```
---
#### Обработка ошибок

---
- Все 3 коробки **null**
```java
Box<Integer> box1 = null;
Box<Double> box2 = null;
Box<Float> box3 = null;
```
**Вывод**
```
Вам предстоит создать 3 коробки.
Не найдено ни одной не пустой коробки
```
---
## Задача 3
  + ### Задача 3.1 Функция
```
Разработайте такой метод, который будет принимать список значений типа T, и объект имеющий единственный метод apply. 
Данный метод надо применить к каждому элементу списка, и вернуть новый список значений типа P, при этом типы T и P могут совпадать, а могут не совпадать.
Используйте разработанный метод следующим образом:
 1. Передайте в метод список со значениями:“qwerty”, “asdfg”, “zx”, а получите список чисел,
где каждое число соответствует длине каждой строки.
 2. Передайте в метод список со значениями: 1,-3,7, а получите список в котором все
отрицательные числа стали положительными, а положительные остались без изменений
 3. Передайте в метод список состоящий из массивов целых чисел, а получите список в
котором будут только максимальные значения каждого из исходных массивов
```
В основной программе пользователю выводиться меню с выбором того, что он хочет сделать.  
 1) Получить список чисел, где каждое число соответствует длине каждой строки.  
Пользователю предлагается выбрать какой длины он хочет составить список, далее используя метод **inputStr(n)** класса **Collecting** заполняем список строками. 
Далее с помощью метода **transformList()** класса **Functi** заполняем новый список числами, где каждое число равно каждой длине строки. Затем
выводим этот массив на экран.
 2) Получить список, в котором отрицательные числа стали положительными, а положительные остались прежними.  
Также пользователя запрашиваем размер списка, а после через метод **inputNumbers(n)** класса **Collecting** заполняем список цифрами. Каждую цифру проверяем 
на правильный ввод с помощью метода **isInt()** класса **Metods**. Далее создаём новый список с помощью метода **transformList()** класса **Functi**, 
в который передаём изначальный список. Получившийся список выводим в консоль.
 3) Получить список, в котором будут написаны только максимальные значения переданных массивов.  
также просим пользователя ввести 2 размера массива, а далее два раза через цикл **for** заполняем массивы цифрами. 
Каждую вводимую цифру проверяем на правильный формат с помощью метода **isInt()** класса **Metods**. Затем создаём новый массив с помощью метода 
**transformList()** класса **Functi**, в который передаём 2 массива. Выводим получившийся список в консоль.  
Для решения использовался класс **Functi**, в котором есть метод **<T, P> List<P> transformList(List<T> sourceList, Function<T, P> function):**  
```java
if (sourceList == null) {
            return new ArrayList<>(); //если переданный список был null, то возвращаем пустой список
        }

        List<P> result = new ArrayList<>();
        for (T item : sourceList) { //проходимся по списку 
            result.add(function.apply(item));
        }
        return result;
```
`function.apply(item)` - вызывается функция преобразования, которая принимает элемент списка типа T и возвращает уже типом P  
`result.add(...)` - результат преобразования добавляется в итоговый список  

Пройдёмся по конкретным параметрам, передаваемым в этот метод в каждом варианте задания:
 1) `List<Integer> stringLengths = Functi.transformList(lines, String::length)`  
Здесь мы передаём наш список строк 1-м параметром, а 2-м ссылку на метод, которая автоматически преобразуется компилятором в реализацию 
функционального интерфейса.
тип `T` - `String`,  
тип `P` - `Integer`

```java
Function<String, Integer> function = new Function<String, Integer>() {
    @Override
    public Integer apply(String s) {
        return s.length();  // ВЫЗОВ МЕТОДА на переданном объекте
    }
};
```
 2) `
List<Number> result = Functi.transformList(digit, i -> {
    double value = i.doubleValue();
    if (value < 0) {
        return Math.abs(value);
    }
    return i;
})`

 Здесь также передаём список чисел 1-м параметром, а 2-м лямбда выражение, по аналогии с предыдущим заданием, где также создаётся ссылка на 
 метод функционального интерфейса.
тип `T` - `Number`,  
тип `P` - `Number`.

Для удобства было решено преобразовывать каждый элемент исходного списка в тип **double**, иначе пришлось бы в лямбде вырождении прописывать для каждого
типа, являющиеся **Number** или наследующиеся от **Number**, отдельно логику преобразования отрицательного значения в положительное.

 3) `List<Number> maxValues = Functi.transformList(arrays, arr -> {
                                                if (arr == null || arr.length == 0) {
                                                    return null;
                                                }
                                                return Arrays.stream(arr)
                                                        .max(Comparator.comparingDouble(Number::doubleValue))
                                                        .orElse(null);
                                            })`  
Как и в предыдущих заданиях передаём 1-м параметром список, в котором каждый элемент это массив чисел. А 2-м лямбда выражение, которое
по аналогии с предыдущим заданием, где также создаётся ссылка на метод функционального интерфейса.
тип `T` - `Number[]`,  
тип `P` - `Number`

Теперь подробнее разберём то, что написано в **return.**  
`Arrays.stream(arr)` - создаём поток Stream для массива чисел, который находится в переданном списке.
Через терминальный метод `.max()` находим максимальное значение в массиве. Для этого в параметрах метода указываем `Comparator` - интерфейс для сравнения объектов.
Из под него вызываем метод`comparingDouble()`, где в параметрах прописываем, что мы работаем с **double** представлением чисел.
А затем для обработки ошибок добавляем `.orElse(null)` - это если компаратор оказался пуст (то есть не нашёл максимальное значение).

#### Пример работы программы
```
--------------1 действие ------------------

Введите число: 4
Сейчас вам предстоит заполнить список значениями
Строка: sadfghjk
Строка: 74
Строка: 1
Строка: kmkm
Исходный список: [sadfghjk, 74, 1, kmkm]
Длины строк: [8, 2, 1, 4]

--------------2 действие ------------------
Сейчас вам предстоит заполнить список значениями
Введите число: 4
Введите число: -785.56
Введите число: -85
Введите число: 47
Введите число: -78.4
Исходный список: [4, -785.56, -85, 47, -78.4]
Результат: [4, 785.56, 85.0, 47, 78.4]

--------------3 действие ------------------
Сейчас будут созданы 2 массива
Сколько чисел будет в списках.При вводе вещественного числа в поле с количеством значений в списке, оно будет преобразовано в значение типа int
Введите число: 4
Введите число: 3
Первый массив.
Введите число: 51651
Введите число: -74
Введите число: 0
Введите число: 98
Второй массив.
Введите число: 71.262
Введите число: -7.22
Введите число: 7

Максимальные значения массивов:
Исходные массивы: [[51651, -74, 0, 98], [71.262, -7.22, 7]]
Максимумы: [51651, 71.262]

```
