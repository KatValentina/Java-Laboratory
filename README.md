<H3>Лабораторная работа №1<H3>
<H2>Структура и условия заданий, а также комментарии к каждому:</H2>

<A HREF="#chap1">Задание 1</A><br>
<A HREF="#chap2">Задание 2</A><br>
<A HREF="#chap3">Задание 3</A><br>
<A HREF="#chap4">Задание 4</A><br>

<A NAME="chap1"></A>
<H1>Задание 1</H1>
<A HREF="#chap1.2">задание 1.2</A><br>
<A HREF="#chap1.4">задание 1.4</A><br>
<A HREF="#chap1.6">задание 1.6</A><br>
<A HREF="#chap1.8">задание 1.8</A><br>
<A HREF="#chap1.10">задание 1.10</A><Br> 

<A NAME="chap1.2"></A>
<b>Задание 1.2</b>
Сумма знаков.<br>
Дана сигнатура метода: <b>public int sumLastNums (int x);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал результат
сложения двух последних знаков числах, предполагая, что знаков в числе не
менее двух.<br>
Пример:<br>
x=4568<br>
результат: 14.<br>
В методе main: <b>if (x>=10)</b> проверяем условие "знаков в числе не
менее двух" и с помощью этого, не обрабатываю отрицательные числа.<br>
В методе <b>public int sumLastNums (int x):</b> в переменную <b>c</b> записываю последние цифры числа, сумму которых просят найти. Возвращаю сумму, которую нахожу при помощи делений разных видов.<br>

<A NAME="chap1.4"></A>
<b>Задание 1.4</b>
Есть ли позитив.<br>
Дана сигнатура метода: <b>public boolean isPositive (int x);</b>
Необходимо реализовать метод таким образом, чтобы он принимал число x и
возвращал true, если оно положительное.<br>
Пример 1:<br>
x=3<br>
результат: true<br>
Пример 2:<br>
x=-5<br>
результат: false<br>
В своём решении учитываю 0. Так как он не является ни положительным, ни отрицательным, то сообщаю пользователю эту информацию, а также обрабатываю его как <b>false</b>.<br>
В методе <b>public boolean isPositive (int x)</b> использую конструкцию <b>x > 0</b> при определении положительное или отрицательное число. Так как метод возвращает логический тип данных, то это позволяет использовать эту конструкцию. При x>0 возвращается <b>true</b>, иначе <b>false</b>.

<A NAME="chap1.6"></A>
<b>Задание 1.6</b>
Большая буква.<br>
Дана сигнатура метода: <b>public boolean isUpperCase (char x);</b><br>
Необходимо реализовать метод таким образом, чтобы он принимал символ x и
возвращал true, если это большая буква в диапазоне от ‘A’ до ‘Z’.<br>
Пример 1:<br>
x=’D’<br>
результат: true<br>
Пример 2:<br>
x=’q’<br>
результат: false<br>
Символы, отличные от заглавных букв латинского алфавита, при обработке будут выдавать <b>false</b>.<br>
В методе <b>public boolean isUpperCase (char x);</b> решение осуществляю проверкой условия <b>'A'<=x && x<='Z'</b>. Если символ принадлежит диапазону латинских заглавных букв по кодировке <b>ASCII</b>(где символы представлены определённым набором чисел), то вернёт <b>true</b>, иначе <b>false</b>.

<A NAME="chap1.8"></A>
<b>Задание 1.8</b>
Делитель.<br>
Дана сигнатура метода: <b>public boolean isDivisor (int a, int b);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
любое из принятых чисел делит другое нацело.<br>
Пример 1:<br>
a=3 b=6<br>
результат: true<br>
Пример 2:<br>
a=2 b=15<br>
результат: false<br>
B ходе решения предполагается исключение(деление на 0 невозможно), поэтому в методе <b>public boolean isDivisor (int a, int b);</b> такая конструкция:<br>
if (a!=0 && b!=0) { <= случай, когда оба числа не 0<br>
	return a%b==0 || b%a==0; <= в зависимости от решения строчки будет true или false<br>
} else if (a==0 && b==0) { <= случай, когда оба числа ноль<br>
	return false; <= в этом случае однозначно false<br>
} else {
	return true; <= когда (Пример: а = 6 и b = 0. Ноль мы можем нацело поделить на 6 и в результате будет тоже 0, а т.к 0 - целое число => будет возвращено true)<br>
}

<A NAME="chap1.10"></A>
<b>Задание 1.10</b>
Многократный вызов.<br>
Дана сигнатура метода: <b>public int lastNumSum(int a, int b)</b><br>
Необходимо реализовать метод таким образом, чтобы он считал сумму цифр
двух чисел из разряда единиц. Выполните с его помощью последовательное
сложение пяти чисел и результат выведите на экран. Постарайтесь выполнить
задачу, используя минимально возможное количество вспомогательных
переменных.<br>
Пример:<br>
5+11 это 6<br>
6+123 это 9<br>
9+14 это 13<br>
13+1 это 4<br>
Итого 4<br>
В методе main осуществляется вызов метода <b>public int lastNumSum(int a, int b)</b> 4 раза, т.к этого достаточно при сложении чисел из разряда единиц пяти чисел.<br>
В цикле <b>for (int i=0;i<3;i++)</b> обновляется переменная <b>a</b> (туда как раз вносится сумма чисел из разряда едениц), а также обновляется переменная <b>b</b><br>
В методе <b>public int lastNumSum(int a, int b)</b>: <br>
1) Если были введены отрицательные числа, то меняем их на положительные<br>
2) Находим числа из разряда единиц<br>
Пример, если бы мы не сделали шаг 1: <br>
a = -123 , b = 45 => Сумма чисел из разряда была бы (-123%10 = -3) + (45%10 = 4) = 1. Что не является верным.<br>
3) Находим сумму чисел из разряда единиц и возвращаем её в переменную <b>a</b><br>.

<A NAME="chap2"></A>
<H1>Задание 2</H1>
<A HREF="#chap2.2">задание 1.2</A><br>
<A HREF="#chap2.4">задание 1.4</A><br>
<A HREF="#chap2.6">задание 1.6</A><br>
<A HREF="#chap2.8">задание 1.8</A><br>
<A HREF="#chap2.10">задание 1.10</A><Br>

<A NAME="chap2.2"></A>
<b>Задание 2.2</b>
Безопасное деление.<br>
Дана сигнатура метода: <b>public double safeDiv (int x, int y);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал деление x
на y, и при этом гарантировал, что не будет выкинута ошибка деления на 0. При
делении на 0 следует вернуть из метода число 0. Подсказка: смотри
ограничения на операции типов данных.<br>
Пример 1:<br>
x=5 y=0<br>
результат: 0<br>
Пример 2:<br>
x=8 y=2<br>
результат: 4<br>
В методе <b>public double safeDiv (int x, int y);</b> добавлено условие <b>if (x==0 || y==0)</b>, которое возвращает 0 при делении на 0 (как по условию), а также возвращает 0, когда 0 делят на какое-либо число. Так как метод должен возвращать тип <b>double</b>, то в строке <b>return (double) x/y</b> прописываем double. Поскольку при делении двух переменных типа <b>int</b> тоже получается тип <b>int</b>.

<A NAME="chap2.4"></A>
<b>Задание 2.4</b>
Строка сравнения.<br>
Дана сигнатура метода: <b>public String makeDecision (int x, int y);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал строку,
которая включает два принятых методом числа и корректно выставленный
знак операции сравнения (больше, меньше, или равно).<br>
Пример 1:<br>
x=5 y=7<br>
результат: “5 < 7”<br>
Пример 2:<br>
x=8 y=-1<br>
результат: “8 > -1”<br>
Пример 3:<br>
x=4 y=4<br>
результат: “4 == 4”<br>
В методе <b>public String makeDecision (int x, int y);</b> используются простые сравнения <b>if (x!=y)</b> и <b>if (x>y)</b>. Так как метод должен возвращать тип <b>String</b>, то для возвращения строки с готовым сравнением используется метод <b>toString()</b> класса <b>Integer</b>, который возвращает объект <b>String</b>, представляющий указанное целое число.

<A NAME="chap2.6"></A>
<b>Задание 2.6</b>
Тройная сумма.<br>
Дана сигнатура метода: <b>public boolean sum3 (int x, int y, int z);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
два любых числа (из трех принятых) можно сложить так, чтобы получить
третье.<br>
Пример 1:<br>
x=5 y=7 z=2<br>
результат: true<br>
Пример 2:<br>
x=8 y=-1 z=4<br>
результат: false<br>
Результат определяется в методе <b>public boolean sum3 (int x, int y, int z);</b> с помощью конструкции <b>(x+y==z || x+z==y || y+z==x)</b>. Если хотя бы одно из условий правдиво (=true), то результат работы метода будет возвращённый <b>true</b>. Только когда все условия ложны(=false), то будет возвращён <b>false</b>.<br>

<A NAME="chap2.8"></A>
<b>Задание 2.8</b>
Возраст.<br>
Дана сигнатура метода: <b>public String age (int x);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал строку, в
которой сначала будет число х, а затем одно из слов:<br>
год<br>
года<br>
лет<br>
Слово “год” добавляется, если число х заканчивается на 1, кроме числа 11.<br>
Слово “года” добавляется, если число х заканчивается на 2, 3 или 4, кроме чисел
12, 13, 14.<br>
Слово “лет” добавляется во всех остальных случаях.<br>
Подсказка: оператор % позволяет получить остаток от деления.<br>
Пример 1:<br>
x=5<br>
результат: “5 лет”<br>
Пример 2:<br>
x=31<br>
результат: “31 год”<br>
Пример 3:<br>
x=44<br>
результат: “44 года”<br>
В методе main происходит проверка, чтобы введённый год пользователем был строго больше 0 и после этой проверки вызывается метод <b>public String age (int x);</b>. В нём находится последняя цифра года, а далее:<br>
if (s>4 || (x>=11 && x<=14)) { <=проверяем на особенные случаи (исключаем их)<br>
	return Integer.toString(x)+" лет";<br>
} else if (s>=2) { <= оканчиваются на 2,3,4,кроме чисел 12, 13, 14 <br>
	return Integer.toString(x)+" года";<br>
} else {<br>
	return Integer.toString(x)+" год";<=оканчиваются на 1, кроме 11<br>
}<br>

<A NAME="chap2.10"></A>
<b>Задание 2.10</b>
Вывод дней недели.<br>
Дана сигнатура метода: <b>public void printDays (String x);</b><br>
В качестве параметра метод принимает строку, в которой записано название
дня недели. Необходимо реализовать метод таким образом, чтобы он выводил
на экран название переданного в него дня и всех последующих до конца недели
дней. Если в качестве строки передан не день, то выводится текст “это не день
недели”. Первый день понедельник, последний – воскресенье. Вместо if в данной
задаче используйте switch.<br>
Пример 1:<br>
x=”четверг” <br>
результат:<br>
четверг <br>
пятница <br>
суббота <br>
воскресенье <br>
Пример 2:<br>
x=”чг”<br>
результат:<br>
это не день недели <br>
При считывании дня недели в методе main использовался только метод <b>next()</b>, поскольку он позволяет дождаться ввода какого-либо символа(не будет проверки на пустую строку), а также он не считывает остальные символы после пробела.