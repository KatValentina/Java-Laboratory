<H3>Лабораторная работа №1<H3>
<H2>Структура и условия заданий, а также комментарии к каждому:</H2>

<A HREF="#chap1">Задание 1</A><br>
<A HREF="#chap2">Задание 2</A><br>
<A HREF="#chap3">Задание 3</A><br>
<A HREF="#chap4">Задание 4</A><br>

<A NAME="chap1"></A>
<H1>Задание 1</H1>
<A HREF="#chap1.2">задание 1.2</A><br>
<A HREF="#chap1.4">задание 1.4</A><br>
<A HREF="#chap1.6">задание 1.6</A><br>
<A HREF="#chap1.8">задание 1.8</A><br>
<A HREF="#chap1.10">задание 1.10</A><Br> 

<A NAME="chap1.2"></A>
<b>Задание 1.2</b>
Сумма знаков.<br>
Дана сигнатура метода: <b>public int sumLastNums (int x);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал результат
сложения двух последних знаков числах, предполагая, что знаков в числе не
менее двух.<br>
Пример:<br>
x=4568<br>
результат: 14.<br>
В методе main: <b>if (x>=10)</b> проверяем условие "знаков в числе не
менее двух" и с помощью этого, не обрабатываю отрицательные числа.<br>
В методе <b>public int sumLastNums (int x):</b> в переменную <b>c</b> записываю последние цифры числа, сумму которых просят найти. Возвращаю сумму, которую нахожу при помощи делений разных видов.<br>

<A NAME="chap1.4"></A>
<b>Задание 1.4</b>
Есть ли позитив.<br>
Дана сигнатура метода: <b>public boolean isPositive (int x);</b>
Необходимо реализовать метод таким образом, чтобы он принимал число x и
возвращал true, если оно положительное.<br>
Пример 1:<br>
x=3<br>
результат: true<br>
Пример 2:<br>
x=-5<br>
результат: false<br>
В своём решении учитываю 0. Так как он не является ни положительным, ни отрицательным, то сообщаю пользователю эту информацию, а также обрабатываю его как <b>false</b>.<br>
В методе <b>public boolean isPositive (int x)</b> использую конструкцию <b>x > 0</b> при определении положительное или отрицательное число. Так как метод возвращает логический тип данных, то это позволяет использовать эту конструкцию. При x>0 возвращается <b>true</b>, иначе <b>false</b>.

<A NAME="chap1.6"></A>
<b>Задание 1.6</b>
Большая буква.<br>
Дана сигнатура метода: <b>public boolean isUpperCase (char x);</b><br>
Необходимо реализовать метод таким образом, чтобы он принимал символ x и
возвращал true, если это большая буква в диапазоне от ‘A’ до ‘Z’.<br>
Пример 1:<br>
x=’D’<br>
результат: true<br>
Пример 2:<br>
x=’q’<br>
результат: false<br>
Символы, отличные от заглавных букв латинского алфавита, при обработке будут выдавать <b>false</b>.<br>
В методе <b>public boolean isUpperCase (char x);</b> решение осуществляю проверкой условия <b>'A'<=x && x<='Z'</b>. Если символ принадлежит диапазону латинских заглавных букв по кодировке <b>ASCII</b>(где символы представлены определённым набором чисел), то вернёт <b>true</b>, иначе <b>false</b>.

<A NAME="chap1.8"></A>
<b>Задание 1.8</b>
Делитель.<br>
Дана сигнатура метода: <b>public boolean isDivisor (int a, int b);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
любое из принятых чисел делит другое нацело.<br>
Пример 1:<br>
a=3 b=6<br>
результат: true<br>
Пример 2:<br>
a=2 b=15<br>
результат: false<br>
B ходе решения предполагается исключение(деление на 0 невозможно), поэтому в методе <b>public boolean isDivisor (int a, int b);</b> такая конструкция:<br>
if (a!=0 && b!=0) { <= случай, когда оба числа не 0<br>
	return a%b==0 || b%a==0; <= в зависимости от решения строчки будет true или false<br>
} else if (a==0 && b==0) { <= случай, когда оба числа ноль<br>
	return false; <= в этом случае однозначно false<br>
} else {
	return true; <= когда (Пример: а = 6 и b = 0. Ноль мы можем нацело поделить на 6 и в результате будет тоже 0, а т.к 0 - целое число => будет возвращено true)<br>
}

<A NAME="chap1.10"></A>
<b>Задание 1.10</b>
Многократный вызов.<br>
Дана сигнатура метода: <b>public int lastNumSum(int a, int b)</b><br>
Необходимо реализовать метод таким образом, чтобы он считал сумму цифр
двух чисел из разряда единиц. Выполните с его помощью последовательное
сложение пяти чисел и результат выведите на экран. Постарайтесь выполнить
задачу, используя минимально возможное количество вспомогательных
переменных.<br>
Пример:<br>
5+11 это 6<br>
6+123 это 9<br>
9+14 это 13<br>
13+1 это 4<br>
Итого 4<br>
В методе main осуществляется вызов метода <b>public int lastNumSum(int a, int b)</b> 4 раза, т.к этого достаточно при сложении чисел из разряда единиц пяти чисел.<br>
В цикле <b>for (int i=0;i<3;i++)</b> обновляется переменная <b>a</b> (туда как раз вносится сумма чисел из разряда едениц), а также обновляется переменная <b>b</b><br>
В методе <b>public int lastNumSum(int a, int b)</b>: <br>
1) Если были введены отрицательные числа, то меняем их на положительные<br>
2) Находим числа из разряда единиц<br>
Пример, если бы мы не сделали шаг 1: <br>
a = -123 , b = 45 => Сумма чисел из разряда была бы (-123%10 = -3) + (45%10 = 4) = 1. Что не является верным.<br>
3) Находим сумму чисел из разряда единиц и возвращаем её в переменную <b>a</b><br>.

<A NAME="chap2"></A>
<H1>Задание 2</H1>
<A HREF="#chap2.2">задание 2.2</A><br>
<A HREF="#chap2.4">задание 2.4</A><br>
<A HREF="#chap2.6">задание 2.6</A><br>
<A HREF="#chap2.8">задание 2.8</A><br>
<A HREF="#chap2.10">задание 2.10</A><Br>

<A NAME="chap2.2"></A>
<b>Задание 2.2</b>
Безопасное деление.<br>
Дана сигнатура метода: <b>public double safeDiv (int x, int y);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал деление x
на y, и при этом гарантировал, что не будет выкинута ошибка деления на 0. При
делении на 0 следует вернуть из метода число 0. Подсказка: смотри
ограничения на операции типов данных.<br>
Пример 1:<br>
x=5 y=0<br>
результат: 0<br>
Пример 2:<br>
x=8 y=2<br>
результат: 4<br>
В методе <b>public double safeDiv (int x, int y);</b> добавлено условие <b>if (x==0 || y==0)</b>, которое возвращает 0 при делении на 0 (как по условию), а также возвращает 0, когда 0 делят на какое-либо число. Так как метод должен возвращать тип <b>double</b>, то в строке <b>return (double) x/y</b> прописываем double. Поскольку при делении двух переменных типа <b>int</b> тоже получается тип <b>int</b>.

<A NAME="chap2.4"></A>
<b>Задание 2.4</b>
Строка сравнения.<br>
Дана сигнатура метода: <b>public String makeDecision (int x, int y);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал строку,
которая включает два принятых методом числа и корректно выставленный
знак операции сравнения (больше, меньше, или равно).<br>
Пример 1:<br>
x=5 y=7<br>
результат: “5 < 7”<br>
Пример 2:<br>
x=8 y=-1<br>
результат: “8 > -1”<br>
Пример 3:<br>
x=4 y=4<br>
результат: “4 == 4”<br>
В методе <b>public String makeDecision (int x, int y);</b> используются простые сравнения <b>if (x!=y)</b> и <b>if (x>y)</b>. Так как метод должен возвращать тип <b>String</b>, то для возвращения строки с готовым сравнением используется метод <b>toString()</b> класса <b>Integer</b>, который возвращает объект <b>String</b>, представляющий указанное целое число.

<A NAME="chap2.6"></A>
<b>Задание 2.6</b>
Тройная сумма.<br>
Дана сигнатура метода: <b>public boolean sum3 (int x, int y, int z);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
два любых числа (из трех принятых) можно сложить так, чтобы получить
третье.<br>
Пример 1:<br>
x=5 y=7 z=2<br>
результат: true<br>
Пример 2:<br>
x=8 y=-1 z=4<br>
результат: false<br>
Результат определяется в методе <b>public boolean sum3 (int x, int y, int z);</b> с помощью конструкции <b>(x+y==z || x+z==y || y+z==x)</b>. Если хотя бы одно из условий правдиво (=true), то результат работы метода будет возвращённый <b>true</b>. Только когда все условия ложны(=false), то будет возвращён <b>false</b>.<br>

<A NAME="chap2.8"></A>
<b>Задание 2.8</b>
Возраст.<br>
Дана сигнатура метода: <b>public String age (int x);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал строку, в
которой сначала будет число х, а затем одно из слов:<br>
год<br>
года<br>
лет<br>
Слово “год” добавляется, если число х заканчивается на 1, кроме числа 11.<br>
Слово “года” добавляется, если число х заканчивается на 2, 3 или 4, кроме чисел
12, 13, 14.<br>
Слово “лет” добавляется во всех остальных случаях.<br>
Подсказка: оператор % позволяет получить остаток от деления.<br>
Пример 1:<br>
x=5<br>
результат: “5 лет”<br>
Пример 2:<br>
x=31<br>
результат: “31 год”<br>
Пример 3:<br>
x=44<br>
результат: “44 года”<br>
В методе main происходит проверка, чтобы введённый год пользователем был строго больше 0 (или строго меньше 100) и после этой проверки вызывается метод <b>public String age (int x);</b>. В нём находится последняя цифра года, а далее:<br>
if (s>4 || (x>=11 && x<=14)) { <=проверяем на особенные случаи (исключаем их)<br>
	return Integer.toString(x)+" лет";<br>
} else if (s>=2) { <= оканчиваются на 2,3,4,кроме чисел 12, 13, 14 <br>
	return Integer.toString(x)+" года";<br>
} else {<br>
	return Integer.toString(x)+" год";<=оканчиваются на 1, кроме 11<br>
}<br>

<A NAME="chap2.10"></A>
<b>Задание 2.10</b>
Вывод дней недели.<br>
Дана сигнатура метода: <b>public void printDays (String x);</b><br>
В качестве параметра метод принимает строку, в которой записано название
дня недели. Необходимо реализовать метод таким образом, чтобы он выводил
на экран название переданного в него дня и всех последующих до конца недели
дней. Если в качестве строки передан не день, то выводится текст “это не день
недели”. Первый день понедельник, последний – воскресенье. Вместо if в данной
задаче используйте switch.<br>
Пример 1:<br>
x=”четверг” <br>
результат:<br>
четверг <br>
пятница <br>
суббота <br>
воскресенье <br>
Пример 2:<br>
x=”чг”<br>
результат:<br>
это не день недели <br>
При считывании дня недели в методе main использовался только метод <b>next()</b>, поскольку он позволяет дождаться ввода какого-либо символа(не будет проверки на пустую строку), а также он не считывает остальные символы после пробела.

<A NAME="chap3"></A>
<H1>Задание 3</H1>
<A HREF="#chap3.2">задание 3.2</A><br>
<A HREF="#chap3.4">задание 3.4</A><br>
<A HREF="#chap3.6">задание 3.6</A><br>
<A HREF="#chap3.8">задание 3.8</A><br>
<A HREF="#chap3.10">задание 3.10</A><Br>

<A NAME="chap3.2"></A>
<b>Задание 3.2</b>
Числа наоборот.<br>
Дана сигнатура метода: <b>public String reverseListNums (int x);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал строку, в
которой будут записаны все числа от x до 0 (включительно).<br>
Пример:<br>
x=5<br>
результат: “5 4 3 2 1 0”<br>
В методе main простым условным оператором проверяем x согласно условиям <b>if (x<0)</b>.
В методе <b>public String reverseListNums (int x);</b> с помощью цикла <b>for</b> и метода <b>toString(i)</b> (про который писала выше) составляем строку с обратным отсчётом от x до 0.

<A NAME="chap3.4"></A>
<b>Задание 3.4</b>
Степень числа.<br>
Дана сигнатура метода: <b>public int pow (int x, int y);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал результат
возведения x в степень y.<br>
Подсказка: для получения степени необходимо умножить единицу на число x, и
сделать это y раз, т.е. два в третьей степени это 1*2*2*2<br>
Пример:<br>
x=2<br>
y=5<br>
результат: 32<br>
В методе main проверяем, что степени числа положительная(т.к по условию метод <b>public int pow (int x, int y);</b> должен вернуть целое значение).<br>
В методе <b>public int pow (int x, int y);</b> первое значение числа в степени равно 1 (так как любое a^0==1)а далее уже через цикл <b>for</b> считаем число x в степени y.

<A NAME="chap3.6"></A>
<b>Задание 3.6</b>
Одинаковость.<br>
Дана сигнатура метода: <b>public boolean equalNum (int x);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал true, если
все знаки числа одинаковы, и false в ином случае.<br>
Подсказки:<br>
intx=123%10; // х будет иметь значение 3<br>
intу=123/10; // у будет иметь значение 12<br>
Пример 1:<br>
x=1111<br>
результат: true<br>
Пример 2:<br>
x=1211<br>
результат: false<br>
В методе <b>public boolean equalNum (int x);</b>:
1) Если пользователь ввёл отрицательное число, то меняем его на положительное.
Так как дальше будем работать именно с его "положительностью".<br>
2) Находим последнюю цифру числа.<br>
3) Далее: <br>
while (x > 0) { <=пока все цифры в числе "не закончились". <br>
	if (x % 10 != c) { <= если "конец" числа не равен с самого начала найденной последней цифрой <br>
		return false; <= Нашли различие в числе <br>
	} 
	x = x/10; <= обновляем число, убираем проверенную последнюю цифру<br>
}<br>

<A NAME="chap3.8"></A>
<b>Задание 3.8</b>
Левый треугольник.<br>
Дана сигнатура метода: <b>public void leftTriangle (int x);</b><br>
Необходимо реализовать метод таким образом, чтобы он выводил на экран
треугольник из символов ‘*’ у которого х символов в высоту, а количество
символов в ряду совпадает с номером строки.<br>
Пример 1:<br>
x=2<br>
результат:<br>
*<br>
**<br>
Пример 2:<br>
x=4<br>
результат:<br>
*<br>
**<br>
***<br>
****<br>
В методе main проверяем, что число строго больше 0(т.к треугольника с 0 стороной нет).
В методе <b>public void leftTriangle (int x);</b> индекс i - отвечает за длину стороны(по строкам), а y - отвечает за количество  звёздочек в строке.<br>

<A NAME="chap3.10"></A>
<b>Задание 3.10</b>
Угадайка.<br>
Дана сигнатура метода: <b>public void guessGame()</b><br>
Необходимо реализовать метод таким образом, чтобы он генерировал
случайное число от 0 до 9, далее считывал с консоли введенное пользователем
число и выводил, угадал ли пользователь то, что было загадано, или нет. Метод
запускается до тех пор, пока пользователь не угадает число. После этого
выведите на экран количество попыток, которое потребовалось пользователю,
чтобы угадать число.<br>
Пример:<br>
Введите число от 0 до 9:<br>
5<br>
Вы не угадали, введите число от 0 до 9:<br>
9<br>
Вы угадали!<br>
Вы отгадали число за 2 попытки<br>
В методе <b>public void guessGame()</b> с помощью подключённого пакета <b>java.util.Random</b> выбирается число компьютером. Инициализируется счётчик попыток.
Используя цикл <b>while (comp != user)</b> игра продолжается, пока пользователь не введёт такое же число, которое "загадал" компьютер.

<A NAME="chap4"></A>
<H1>Задание 4</H1>
<A HREF="#chap4.0">Дополнительно</A><br>
<A HREF="#chap4.2">задание 4.2</A><br>
<A HREF="#chap4.4">задание 4.4</A><br>
<A HREF="#chap4.6">задание 4.6</A><br>
<A HREF="#chap4.8">задание 4.8</A><br>
<A HREF="#chap4.10">задание 4.10</A><Br>

<A NAME="chap4.0"></A>
<b>Дополнительно</b>
Чтобы облегчить выполнение этого блока задач были написаны 2 метода: <br>
1) <b>public int[] addArr(int n)</b> - метод для заполнения массива числами (использует цикл for)<br>
2) <b>public void printArr(int[] arr)</b> - метод для вывод массива в консоль (тоже использует цикл for)
Также во всех заданиях выполняется проверка на размер массива(строго больше 0)

<A NAME="chap4.2"></A>
<b>Задание 4.2</b>
Поиск последнего значения.<br>
Дана сигнатура метода: <b>public int findLast (int[] arr, int x);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал индекс
<u>последнего</u> вхождения числа x в массив arr. Если число не входит в массив –
возвращается -1.<br>
Пример:<br>
arr=[1,2,3,4,2,2,5]<br>
x=2<br>
результат: 5<br>
После проверки размера массива, заполнения его данными и ввода числа x в методе <b>public int findLast (int[] arr, int x);</b> циклом <b>for</b> проходим массив с конца и ищем число в массиве равное числу х. Как только мы его находим, возвращаем его индекс. Если мы достигли конца массива, но не нашли равенство, то возвращаем -1.

<A NAME="chap4.4"></A>
<b>Задание 4.4</b>
Добавление в массив.<br>
Дана сигнатура метода: <b>public int[]add (int[] arr, int x, int pos);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, который будет содержать все элементы массива arr, однако в позицию
pos будет вставлено значение x.<br>
Пример:<br>
arr=[1,2,3,4,5]<br>
x=9<br>
pos=3<br>
результат: [1,2,3,9,4,5]<br>
После проверки размера массива, заполнения его данными, ввода числа x и ещё проверкой введённой позиции (индекса) pos (не должен выходить за рамки массива) вызываем метод <b>public int[]add (int[] arr, int x, int pos);</b>. В методе создаём новый массив размером больше на 1 изначального(т.к добавляем 1 число). Переписываем все данные до места вставки, потом записываем число х на индекс(pos), далее также заполняем новый массив данными из старого массива, включая число, которое раньше стояло на месте x. Используем циклы <b>for</b>.

<A NAME="chap4.6"></A>
<b>Задание 4.6</b>
Реверс.<br>
Дана сигнатура метода: <b>public void reverse (int[] arr);</b><br>
Необходимо реализовать метод таким образом, чтобы он изменял массив arr.
После проведенных изменений массив должен быть записан задом-наперед.<br>
Пример:<br>
arr=[1,2,3,4,5]<br>
результат: arr=[5,4,3,2,1]<br>
После проверки размера массива и заполнения массива данными, вызываем метод <b>public void reverse (int[] arr);</b>:<br>
Мы мысленно делим массив пополам и будем менять данные пар с индексами {0,n}; {1,n-1} и т.д.<br>
Для этого в цикле <b>for</b> сохраняем данные 1 числа из пары. На место 1 числа пары ставим второе число пары, далее записываем на 2 число пары данные 1 числа(которые сохранили) и т.д, пока не поменяем данные внутри последней пары.<br> 

<A NAME="chap4.8"></A>
<b>Задание 4.8</b>
Объединение.<br>
Дана сигнатура метода: <b>public int[] concat (int[] arr1,int[] arr2);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, в котором сначала идут элементы первого массива (arr1), а затем
второго (arr2).<br>
Пример:<br>
arr1=[1,2,3]<br>
arr2=[7,8,9]<br>
результат: [1,2,3,7,8,9]<br>
Заполняем 2 массива данными и вызываем метод <b>public int[] concat (int[] arr1,int[] arr2);</b>.Для того, чтобы соединить 2 массива в 1 массив (третий) найдём его размер (размер 1 + размер 2). И сначала в новый третий массив записываем 1 массив через цикл <b>for</b>. А далее так же через цикл <b>for</b> записываем данные 2 массива в третий массив.

<A NAME="chap4.10"></A>
<b>Задание 4.10</b>
Удалить негатив.<br>
Дана сигнатура метода: <b>public int[] deleteNegative (int[] arr);</b><br>
Необходимо реализовать метод таким образом, чтобы он возвращал новый
массив, в котором записаны все элементы массива arr кроме отрицательных.
Пример:<br>
arr=[1,2,-3,4,-2,2,-5]<br>
результат: [1,2,4,2]<br>
Как в задачах до этого заполняем массив значениями и вызываем метод <b>public int[] deleteNegative (int[] arr);</b>. В нём считаем количество отрицательных чисел в массиве:<br>
1) Если их не оказалось, то возвращаем тот же самый массив.<br>
2) Если количество отриц. чисел равно размеру массива, то выводим пустой массив.<br>
3) Если количество меньше длины массива, то создаём новый массив, длинной (длинна изначального массива - количество отриц. чисел). И через цикл <b>for</b> заполняем новый массив положительными числами(0 тоже) из старого. => Выводим новый массив.<br>
 